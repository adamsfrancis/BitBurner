import * as hackTools from '/tools/tools.ns';
import { portHandles } from '/tools/constants.ns';
import * as serverUtils from '/tools/serverTools.ns'
import { CodingContract } from '/Classes/codingContract.ns'

const weakenChange = 0.05
const hackChange = 0.002
const growChange = 0.004
const growRam = 1.75
const hackRam = 1.70
const weakenRam = 1.75

export async function main(ns) {
	while (true) {
		let targetMap = await ns.read(portHandles.targetMap);
		let usableMap = await ns.read(portHandles.usableMap);
		let serverMap = await ns.read(portHandles.serverMap);
		if (targetMap.length > 0) {
			if (!serverUtils.isOptimal(ns, targetMap[0])) {
				ns.tprint("Sending " + targetMap[0].serverName + " for prep.")
				await prepServer(ns, targetMap[0], usableMap)
			} else {
				ns.tprint("Attacking " + targetMap[0].serverName)
				await attackServer(ns, targetMap[0], usableMap)
			}
		}
		await ns.sleep(1)
		await solveContracts(ns, serverMap)
	}
}
async function attackServer(ns, target, usableMap) {
	let canAttack = true;
	let jobsRan = 0;
	let hackTime = await ns.getHackTime(target.serverName)*1000;
	let growTime = await hackTime*3.2;
	let weakenTime = await hackTime*4;
	let weakenDelay = new Date(Date.now() +3000)
	let growDelay = new Date(Date.now()+(weakenTime-growTime)+2999);
	let hackDelay = new Date(Date.now()+(weakenTime-hackTime)+2998);
	let maxThreads = await getMaxThreads(ns, hackTools.hackTools.weaken, usableMap);
	let hackAmount = target.moneyMax * 0.9
	let hacksNeeded = await Math.ceil(ns.hackAnalyzeThreads(target.serverName, hackAmount));
	let neededGrowThreads = await Math.ceil(ns.growthAnalyze(target.serverName, 1 + (hacksNeeded * ns.hackAnalyzePercent(target.serverName))));
	let neededWeakenThreads = await Math.ceil(((hacksNeeded * 0.002) + (neededGrowThreads * 0.004)) / weakenChange);
	let jobThreadsNeeded = hacksNeeded + neededGrowThreads + neededWeakenThreads;
	let totalJobSize = jobThreadsNeeded;
	if (jobThreadsNeeded > maxThreads) {
		while (jobThreadsNeeded > maxThreads) {
			hacksNeeded -= 1;
			neededGrowThreads = await Math.ceil(ns.growthAnalyze(target.serverName, 1 + (hacksNeeded * ns.hackAnalyzePercent(target.serverName))));
			neededWeakenThreads = await Math.ceil(((hacksNeeded * 0.002) + (neededGrowThreads * 0.004)) / weakenChange);
			jobThreadsNeeded = hacksNeeded + neededGrowThreads + neededWeakenThreads;
			await ns.sleep(1)
		}
	}
	while(canAttack){
		let jobGrow = neededGrowThreads;
		let jobHacks = hacksNeeded;
		let jobWeaken = neededWeakenThreads;
	for (let i = 0; i < usableMap.length; i++) {
		if (jobHacks > 0) {
			let servThreads = await Math.floor(serverUtils.getRam(ns, usableMap[i]) / hackRam)
			if (servThreads > 0) {
				if (jobHacks > servThreads) {
					ns.exec(hackTools.hackTools.hack, usableMap[i].serverName, servThreads, target.serverName, hackDelay+(4*jobsRan));
					jobHacks -= servThreads;
				} else if (jobHacks <= servThreads) {
					ns.exec(hackTools.hackTools.hack, usableMap[i].serverName, jobHacks, target.serverName, hackDelay+(4*jobsRan));
					jobHacks -= jobHacks;
				}
			}
		}
		if (jobGrow > 0) {
			let servThreads = await Math.floor(serverUtils.getRam(ns, usableMap[i]) / growRam)
			if (servThreads > 0) {
				if (jobGrow > servThreads) {
					ns.exec(hackTools.hackTools.grow, usableMap[i].serverName, servThreads, target.serverName, growDelay+(4*jobsRan));
					jobGrow -= servThreads;
				} else if (jobGrow <= servThreads) {
					ns.exec(hackTools.hackTools.grow, usableMap[i].serverName, jobGrow, target.serverName, growDelay+(4*jobsRan));
					jobGrow -= jobGrow;
				}
			}

		}
		if (jobWeaken > 0) {
			let servThreads = await Math.floor(serverUtils.getRam(ns, usableMap[i]) / weakenRam)
			if (servThreads > 0) {
				if (jobWeaken > servThreads) {
					ns.exec(hackTools.hackTools.weaken, usableMap[i].serverName, servThreads, target.serverName, weakenDelay+(4*jobsRan));
					jobWeaken -= servThreads;
				} else if (jobWeaken <= servThreads) {
					ns.exec(hackTools.hackTools.weaken, usableMap[i].serverName, jobWeaken, target.serverName, weakenDelay+(4*jobsRan));
					jobWeaken -= jobWeaken;
				}
			}
		}
	}
	jobsRan +=1;
	if(totalJobSize*1.3 >= maxThreads || jobsRan >= 10000){canAttack=false;}
	await ns.sleep(1)
}
ns.tprint("Started " + jobsRan + " jobs in: " + (Date.now()-weakenDelay-3000)/1000 + " seconds.")
	await ns.sleep((ns.getWeakenTime(target.serverName) + 6) * 1000)

}

async function prepServer(ns, target, usableMap) {
	let maxThreads = await getMaxThreads(ns, hackTools.hackTools.weaken, usableMap);
	let neededWeakenThreads = await Math.ceil((ns.getServerSecurityLevel(target.serverName) - target.minSecurityLevel) / weakenChange)
	let neededGrowThreads = await Math.ceil(ns.growthAnalyze(target.serverName, target.moneyMax / ns.getServerMoneyAvailable(target.serverName)))
	let compensationThreads = Math.ceil((neededGrowThreads * growChange) / weakenChange);
	if (maxThreads < (neededWeakenThreads + neededGrowThreads + compensationThreads)) {
		//can I fit the initial weakens?
		if (neededWeakenThreads <= maxThreads) {
			let availThreads = maxThreads - neededWeakenThreads
			while (availThreads < (neededGrowThreads + compensationThreads)) {
				neededGrowThreads -= 1;
				compensationThreads = (neededGrowThreads * growChange) / weakenChange;
			}

		} else {
			neededWeakenThreads = maxThreads;
			neededGrowThreads = 0;
			compensationThreads = 0;
		}
	}
	neededWeakenThreads += compensationThreads;
	if (neededWeakenThreads > 0) {
		for (let i = 0; i < usableMap.length; i++) {
			let servThreads = await Math.floor(serverUtils.getRam(ns, usableMap[i]) / weakenRam)
			if (neededWeakenThreads > 0) {
				if (servThreads > 0) {
					if (neededWeakenThreads > servThreads) {
						ns.exec(hackTools.hackTools.weaken, usableMap[i].serverName, servThreads, target.serverName);
						neededWeakenThreads -= servThreads;
					} else if (neededWeakenThreads <= servThreads) {
						ns.exec(hackTools.hackTools.weaken, usableMap[i].serverName, neededWeakenThreads, target.serverName);
						neededWeakenThreads -= neededWeakenThreads;
					}
				}
			}
		}
	}
	if (neededGrowThreads > 0) {
		for (let i = 0; i < usableMap.length; i++) {
			let servThreads = await Math.floor(serverUtils.getRam(ns, usableMap[i]) / growRam)
			if (neededGrowThreads > 0) {
				if (servThreads > 0) {
					if (neededGrowThreads > servThreads) {
						ns.exec(hackTools.hackTools.grow, usableMap[i].serverName, servThreads, target.serverName);
						neededGrowThreads -= servThreads;
					} else if (neededGrowThreads <= servThreads) {
						ns.exec(hackTools.hackTools.grow, usableMap[i].serverName, neededGrowThreads, target.serverName);
						neededGrowThreads -= neededGrowThreads;
					}
				}
			}
		}
	}
	await ns.sleep((ns.getWeakenTime(target.serverName) + 6) * 1000)
}

async function getMaxThreads(ns, tool, usableMap) {
	let availThreads = 0;
	let toolRam = getToolRam(tool);
	for (let i = 0; i < usableMap.length; i++) {
		availThreads += Math.floor((usableMap[i].ramMax - ns.getServerUsedRam(usableMap[i].serverName)) / toolRam);
	}
	return availThreads;
}
async function getServerUtilization(ns, usableMap) {
	let maxAvail = 0;
	let curUsed = 0;
	for (let i = 0; i < usableMap.length; i++) {
		maxAvail += usableMap[i].ramMax;
		curUsed += ns.getServerUsedRam(usableMap[i].serverName)
	}
	return curUsed / maxAvail;
}

function getToolRam(tool) {
	switch (tool) {
		case hackTools.hackTools.weaken:
			return weakenRam;
		case hackTools.hackTools.grow:
			return growRam;
		case hackTools.hackTools.hack:
			return hackRam;
		default:
			return growRam;
	}
}

async function solveContracts(ns, serverMap) {
	if (serverMap.length > 0) {
		for (let i = 0; i < serverMap.length; i++) {
			const serverContracts = await ns.ls(serverMap[i].serverName, '.cct');
			if (serverContracts.length === 0) {
				continue;
			}
			for (const serverContract of serverContracts) {
				const contract = new CodingContract(ns, serverContract, serverMap[i].serverName)
				const solution = findSolution(ns, contract);
				const isSuccessful = contract.attempt(ns, solution);
				if (isSuccessful) {
					ns.tprint("Solved a contract!")
				}

			}
		}
	}
}
export function findSolution(ns, contract) {
	switch (contract.type) {
		case 'Unique Paths in a Grid I':
			return uniquePathNoObstacle(contract.data[0], contract.data[1]);
		case 'Unique Paths in a Grid II':
			return uniquePathWithObstacle(contract.data);
		case 'Find Largest Prime Factor':
			return largestPrime(contract.data);
		case 'Spiralize Matrix':
			return spiralize(contract.data).toString();
		case 'Array Jumping Game':
			return (canJump(contract.data)) ? 1 : 0;
		case 'Generate IP Addresses':
			return generateIpAddresses(contract.data);
		case 'Algorithmic Stock Trader I':
			return stockTrader(1, contract.data);
		case 'Algorithmic Stock Trader II':
			return stockTrader(Math.ceil(contract.data.length / 2), contract.data);
		case 'Algorithmic Stock Trader III':
			return stockTrader(2, contract.data);
		case 'Algorithmic Stock Trader IV':
			return stockTrader(contract.data[0], (contract.data[1]));
		case 'Sanitize Parentheses in Expression':
			return removeInvalidParentheses(contract.data);
		case 'Subarray with Maximum Sum':
			return maxSubArray(contract.data);
		case 'Total Ways to Sum':
			return waysToSum(contract.data);
		case 'Merge Overlapping Intervals':
			return JSON.stringify(mergeIntervals(contract.data));
		case 'Minimum Path Sum in a Triangle':
			return triangleMinSum(contract.data);
		case 'Find All Valid Math Expressions':
			return findAllExpressions(contract.data[0], contract.data[1]);
		default:
			return null;
	}
}

function stockTrader(maxTrades, stockPrices) {
	let i, j, k;
	// WHY?
	let tempStr = '[0';
	for (i = 0; i < stockPrices.length; i++) {
		tempStr += ',0';
	}
	tempStr += ']';
	let tempArr = '[' + tempStr;
	for (i = 0; i < maxTrades - 1; i++) {
		tempArr += ',' + tempStr;
	}
	tempArr += ']';
	let highestProfit = JSON.parse(tempArr);
	for (i = 0; i < maxTrades; i++) {
		for (j = 0; j < stockPrices.length; j++) { // Buy / Start
			for (k = j; k < stockPrices.length; k++) { // Sell / End
				if (i > 0 && j > 0 && k > 0) {
					highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i][k - 1], highestProfit[i - 1][j - 1] + stockPrices[k] - stockPrices[j]);
				} else if (i > 0 && j > 0) {
					highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i - 1][j - 1] + stockPrices[k] - stockPrices[j]);
				} else if (i > 0 && k > 0) {
					highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i][k - 1], stockPrices[k] - stockPrices[j]);
				} else if (j > 0 && k > 0) {
					highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i][k - 1], stockPrices[k] - stockPrices[j]);
				} else {
					highestProfit[i][k] = Math.max(highestProfit[i][k], stockPrices[k] - stockPrices[j]);
				}
			}
		}
	}
	return highestProfit[maxTrades - 1][stockPrices.length - 1];
}

function isValidIp(octets) {
	for (const octet of octets) {
		const integer = parseInt(octet);
		if (octet.length > 3 || integer < 0 || integer > 255)
			return false;
		if (octet.length > 1) {
			if (integer == 0)
				return false;
			else if (octet.substr(0, 1) === '0')
				return false;
		}
	}
	return true;
}

function generateIpAddresses(data) {
	if (data.length > 12)
		throw new Error('The data provided was wrong');
	let ipAddresses = [];
	for (let i = 1; i < Math.min(4, data.length); i++) {
		for (let j = i + 1; j < Math.min(i + 4, data.length); j++) {
			for (let k = j + 1; k < Math.min(j + 4, data.length); k++) {
				let octet1 = data.substring(0, i);
				let octet2 = data.substring(i, j);
				let octet3 = data.substring(j, k);
				let octet4 = data.substring(k);
				let octets = [octet1, octet2, octet3, octet4];
				if (isValidIp(octets)) {
					ipAddresses.push(octets.join('.'));
				}
			}
		}
	}
	return ipAddresses;
}

function canJump(distances) {
	let idx = 0;
	let max = 0;
	let target = distances.length - 1;
	while (idx < distances.length) {
		max = Math.max(max, idx + distances[idx]);
		if (max >= target) {
			return true;
		}
		if (max <= idx && distances[idx] === 0) {
			return false;
		}
		idx++;
	}
	return false;
}

function spiralize(matrix) {
	const res = [];
	while (matrix.length) {
		const first = matrix.shift();
		res.push(...first);
		for (const m of matrix) {
			let val = m.pop();
			if (val)
				res.push(val);
			m.reverse();
		}
		matrix.reverse();
	}
	return res;
}

function largestPrime(n) {
	let maxPrime = -1;
	let d = 2;
	while (n > 1) {
		while (n % d === 0) {
			maxPrime = Math.max(maxPrime, d);
			n /= d;
		}
		d++;
	}
	return maxPrime;
}

function uniquePathNoObstacle(numRows, numCols) {
	if (numRows == 1 || numCols == 1)
		return 1;
	return uniquePathNoObstacle(numRows - 1, numCols) + uniquePathNoObstacle(numRows, numCols - 1);
}

function uniquePathWithObstacle(grid) {
	if (grid[0][0])
		return 0;
	let m = grid.length,
		n = grid[0].length;
	let dp = Array.from({ length: m }, (el) => {
		return new Uint32Array(n);
	});
	dp[0][0] = 1;
	for (let i = 0; i < m; i++)
		for (let j = 0; j < n; j++)
			if (grid[i][j] || (!i && !j)) {}
	else
		dp[i][j] = (i ? dp[i - 1][j] : 0) + (j ? dp[i][j - 1] : 0);
	return dp[m - 1][n - 1];
}

function hasValidParenthesesString(s) {
	let open = 0;
	for (const c of s) {
		if (c === '(')
			open++; // Increment open brackets
		else if (c === ')') {
			if (open === 0)
				return false; // If closing bracket, but no open bracket, this is invalid
			open--;
		}
	}
	return open === 0; // Open brackets should be zero for valid string
}

function removeInvalidParentheses(s) {
	if (!s || s.length === 0)
		return [''];
	const queue = [s],
		seen = new Set(),
		result = [];
	seen.add(s);
	let validFound = false;
	while (queue.length > 0) {
		let expression = queue.shift();
		// If expression is valid
		if (hasValidParenthesesString(expression)) {
			result.push(expression); // Push to result
			validFound = true;
		}
		if (validFound)
			continue; // If atleast one valid string found, don't do anything
		for (let i = 0; i < expression.length; i++) {
			if (expression[i] !== '(' && expression[i] !== ')') {
				continue; // If expression's i-th character is anything but one of ( or ), continue
			}
			// Calculate next string for consideration
			// Characters 0 to i-th (not including) + Characters (i + 1)th (including) to end
			let next = expression.substring(0, i) + expression.substring(i + 1);
			if (!seen.has(next)) {
				seen.add(next);
				queue.push(next);
			}
		}
	}
	return result;
}

function maxSubArray(A) {
	var prev = 0;
	var max = -Infinity;
	for (var i = 0; i < A.length; i++) {
		prev = Math.max(prev + A[i], A[i]);
		max = Math.max(max, prev);
	}
	return max;
}

function waysToSum(n) {
	let ways = new Array(n + 1);
	ways.fill(0, 1);
	ways[0] = 1;
	for (let i = 1; i < n; ++i) {
		for (let j = i; j <= n; ++j) {
			ways[j] += ways[j - i];
		}
	}
	return ways[n];
}

function mergeIntervals(intervals) {
	if (!intervals.length)
		return intervals;
	intervals.sort((a, b) => a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1]);
	var prev = intervals[0];
	var res = [prev];
	for (var curr of intervals) {
		if (curr[0] <= prev[1]) {
			prev[1] = Math.max(prev[1], curr[1]);
		} else {
			res.push(curr);
			prev = curr;
		}
	}
	return res;
}

function triangleMinSum(triangle) {
	for (let i = triangle.length - 2; i >= 0; i--)
		for (let j = 0; j < triangle[i].length; j++)
			triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]);
	return triangle[0][0];
}

function findAllExpressions(num, target) {
	let res = [];
	if (!num.length)
		return res;

	function solver(path, pos, evaluation, mult) {
		if (pos === num.length) {
			if (target == evaluation)
				res.push(path);
			return;
		}
		for (let i = pos; i < num.length; i++) {
			if (i !== pos && num[pos] === '0')
				break;
			let curr = Number(num.slice(pos, i + 1));
			if (pos == 0) {
				solver(path + curr, i + 1, curr, curr);
			} else {
				solver(`${path}+${curr}`, i + 1, evaluation + curr, curr);
				solver(`${path}-${curr}`, i + 1, evaluation - curr, 0 - curr);
				solver(`${path}*${curr}`, i + 1, evaluation - mult + mult * curr, mult * curr);
			}
		}
	}
	solver('', 0, 0, 0);
	return res;
}